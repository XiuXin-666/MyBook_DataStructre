# 链表

&emsp;&emsp;由于顺序表的插入、删除操作需要移动大量的元素，影响运行效率，由此引进了线性表的链式存储。链式存储线性表时，不需要使用地址连续的存储单元，对线性表的插入删除不需要移动元素，而只需要修改指针。



## 单链表

### &emsp;&emsp;定义：

&emsp;&emsp;每个链表结点，除了存放元素自身的信息外，还需要存放一个指向后继的指针。

```cpp
typedef struct LNode{
    ElemType data;
    struct LNode* next;
}LNode, *LinkList;				//LNode,LinkList 其实是一样的，只是表示结点和链表更方便
```



### &emsp;&emsp;初始化：

#### &emsp;&emsp;不带头结点的单链表

```cpp
bool InitLinklist(LinkList& L){
    L = Nullptr;
    return true;
}
```

#### &emsp;&emsp;带头结点的单链表

```cpp
bool InitLinkList(LinkList& L){
    L = (Lnode*)malloc(sizeof(LNode));	//生成一个头结点
    if( L == Nullptr){					//内存不足，分配失败
        return false;
    }
    L->next = Nullptr;					//头结点之后暂时没有任何结点
    return true;
}
```

&emsp;&emsp;**头结点和头指针的区别**：

&emsp;&emsp;不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，节点内通常不存储信息。

&emsp;&emsp;**引入头结点后的优点**：

&emsp;&emsp;1）由于头结点的位置被存放在头结点的指针域中，所以在链表的第一个位置上的操作和在链表的其他位置上的操作一致，无需进行特殊处理。

&emsp;&emsp;2）无论链表是否为空，其头指针都指向头结点的非空指针（空表中头指针的指针域为空），因此空表和非空表的处理也就得到了统一。



### &emsp;&emsp;建立单链表

#### &emsp;&emsp;头插法

![](Assets/%E9%93%BE%E8%A1%A8.assets/%E5%A4%B4%E6%8F%92%E6%B3%95.jpg)

```cpp
LinkList List_HeadInsert(LinkList& L){
    
    return L;
}
```

